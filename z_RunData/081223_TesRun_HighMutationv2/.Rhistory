dummy <- c(1,2,3,4)
combn(x,2)
combn(dummy,2)
combn(2,dummy)
combn(dummy,2)
a <- combn(dummy,2)
a
a[,1]
a[,2]
a[,3]
a[,4]
install.packages("babette")
install.packages("babette")
install.packages("babette")
install.packages("babette")
library(babette)
library(tidyverse)
library(babette)
library(rJava)
library(rJava)
install.packages("devtools")
install.packages("devtools")
devtools::install_github("richelbilderbeek/beasiterinstall")
remove.packages("devtools")
install.packages("devtools", type = "source")
install.packages("devtools", type = "source")
install.packages("devtools", type = "source")
install.packages("PopGenInfeR", repos="http://R-Forge.R-project.org")
install.packages("Rtools")
The functions used in this lab are specific to the ```PopGenInfeR``` package, which can be installed from GitHub
knitr::opts_chunk$set(echo = TRUE)
```{R eval=FALSE, include=FALSE}
library(devtools)
library(devtools)
library(PopGenInfeR)
library(devtools)
install.packages("devtools")
library(devtools)
install_github("rvitalis/PopGenInfeR")
library(PopGenInfeR)
library(PopGenInfeR)
library(abc)
library(lattice)
prior <- generate.prior(number.of.simulations = 1,prior.theta = 'UNI',min.theta = 1.0,max.theta = 1.0,prior.M = 'UNI',min.M = 1.0,max.M = 1.0)
View(prior)
View(prior)
target <- sim.island.model(number.of.simulations = 1,mutation.model = 'SMM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
target
prior <- generate.prior(number.of.simulations = 1e4,prior.theta = 'UNI',min.theta = 0.1,max.theta = 5.0,prior.M = 'UNI',min.M = 0.1,max.M = 5.0)
head(prior)
stats <- sim.island.model(number.of.simulations = 1e4,mutation.model = 'SMM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
head(stats)
hist(stats$F_ST,breaks = 100,freq = FALSE,main = "",xlab = expression(italic(F)[ST]))
abline(v = target$F_ST,col = "red",lty = 2,lwd = 1.5)
hist(stats$F_ST,breaks = 100,freq = FALSE,main = "",xlab = expression(italic(F)[ST]))
abline(v = target$F_ST,col = "red",lty = 2,lwd = 1.5)
levelplot(cor(stats))
prcp.ca(stats,target)
prcp.ca(stats,target)
rej <- abc(target = target,param = prior,sumstat = stats,tol = 0.1,method = "rejection")
summary(rej)
plot(prior,xlab = expression(italic(theta)),ylab = expression(italic(M)))
plot(prior,xlab = expression(italic(theta)),ylab = expression(italic(M)))
points(rej$unadj.values,col = "red")
plot(prior,xlab = expression(italic(theta)),ylab = expression(italic(M)))
points(rej$unadj.values,col = "red")
hist(rej$unadj.values[,1],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(theta)))
lines(density(prior[,1]))
hist(rej$unadj.values[,2],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(M)))
lines(density(prior[,2]))
hist(rej$unadj.values[,2],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(M)))
lines(density(prior[,2]))
hist(rej$unadj.values[,2],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(M)))
lines(density(prior[,2]))
lin <- abc(target = target,param = prior,sumstat = stats,tol = 0.1,hcorr = FALSE,method = "loclinear",transf = c("none","none"))
summary(lin)
plot(prior,xlab = expression(italic(theta)),ylab = expression(italic(M)))
points(rej$unadj.values,col = "red")
points(lin$adj.values,col = "green")
hist(lin$adj.values[,1],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(theta)))
lines(density(prior[,1]))
hist(lin$adj.values[,2],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(M)))
lines(density(prior[,2]))
prior <- generate.prior(number.of.simulations = 1,prior.theta = 'UNI',min.theta = 1.0,max.theta = 1.0,prior.M = 'UNI',min.M = 1.0,max.M = 1.0)
target <- sim.island.model(number.of.simulations = 1,mutation.model = 'SMM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
prior <- generate.prior(number.of.simulations = 1,prior.theta = 'UNI',min.theta = 1.0,max.theta = 1.0,prior.M = 'UNI',min.M = 1.0,max.M = 1.0)
target <- sim.island.model(number.of.simulations = 1,mutation.model = 'SMM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
prior <- generate.prior(number.of.simulations = 1,prior.theta = 'UNI',min.theta = 1.0,max.theta = 1.0,prior.M = 'UNI',min.M = 1.0,max.M = 1.0)
target <- sim.island.model(number.of.simulations = 1,mutation.model = 'SMM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
prior <- generate.prior(number.of.simulations = 1e4,prior.theta = 'UNI',min.theta = 0.1,max.theta = 5.0,prior.M = 'UNI',min.M = 0.1,max.M = 5.0)
stats <- sim.island.model(number.of.simulations = 1e4,mutation.model = 'SMM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
target.F_ST <- target$F_ST
stats.F_ST <- as.data.frame(stats$F_ST)
target.all <- target
stats.all <- stats
lin <- abc(target = target.F_ST,param = prior,sumstat = stats.F_ST,tol = 0.1,hcorr = FALSE,method = "loclinear",transf = c("none","none"))
plot(prior,cex = 0.1,xlab = expression(italic(theta)),ylab = expression(italic(M)))
points(lin$adj.values,col = "green",pch = 16)
hist(lin$adj.values[,1],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(theta)))
lines(density(prior[,1]))
hist(lin$adj.values[,2],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(M)))
lines(density(prior[,2]))
lin <- abc(target = target.all,param = prior,sumstat = stats.all,tol = 0.1,hcorr = FALSE,method = "loclinear",transf = c("none","none"))
plot(prior,cex = 0.1,xlab = expression(italic(theta)),ylab = expression(italic(M)))
points(lin$adj.values,col = "green",pch = 16)
hist(lin$adj.values[,1],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(theta)))
lines(density(prior[,1]))
hist(lin$adj.values[,2],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(M)))
lines(density(prior[,2]))
prior <- generate.prior(number.of.simulations = 1,prior.theta = 'UNI',min.theta = 10.0,max.theta = 10.0,prior.M = 'UNI',min.M = 10.0,max.M = 10.0)
target <- sim.island.model(number.of.simulations = 1,mutation.model = 'SMM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
prior <- generate.prior(number.of.simulations = 1e4,prior.theta = 'UNI',min.theta = 0.1,max.theta = 5.0,prior.M = 'UNI',min.M = 0.1,max.M = 5.0)
stats <- sim.island.model(number.of.simulations = 1e4,mutation.model = 'SMM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
prcp.ca(stats,target,xlim = c(-10,10),ylim = c(-10,10))
lin <- abc(target = target,param = prior,sumstat = stats,tol = 0.1,hcorr = FALSE,method = "loclinear",transf = c("none","none"))
plot(prior,xlim = c(-10,10),ylim = c(-10,10),xlab = expression(italic(theta)),ylab = expression(italic(M)))
points(lin$adj.values,col = "green")
hist(lin$adj.values[,1],col = "light blue",breaks = 100,freq = FALSE,xlim = c(-10,10),main = "",xlab = expression(italic(theta)))
lines(density(prior[,1]))
hist(lin$adj.values[,2],col = "light blue",breaks = 100,freq = FALSE,xlim = c(-10,10),main = "",xlab = expression(italic(M)))
lines(density(prior[,2]))
prior <- generate.prior(number.of.simulations = 1,prior.theta = 'UNI',min.theta = 1.0,max.theta = 1.0,prior.M = 'UNI',min.M = 1.0,max.M = 1.0)
target <- sim.island.model(number.of.simulations = 1,mutation.model = 'SMM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
prior <- generate.prior(number.of.simulations = 1e4,prior.theta = 'UNI',min.theta = 0.1,max.theta = 5.0,prior.M = 'UNI',min.M = 0.1,max.M = 5.0)
stats <- sim.island.model(number.of.simulations = 1e4,mutation.model = 'IAM',total.number.of.demes = 10,number.of.loci = 20,number.of.sampled.demes = 10,sample.sizes = 50)
prcp.ca(stats,target,xlim = c(-10,10),ylim = c(-10,10))
lin <- abc(target = target,param = prior,sumstat = stats,tol = 0.1,hcorr = FALSE,method = "loclinear",transf = c("none","none"))
plot(prior,xlab = expression(italic(theta)),ylab = expression(italic(M)))
points(lin$adj.values,col = "green")
hist(lin$adj.values[,1],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(theta)))
lines(density(prior[,1]))
hist(lin$adj.values[,2],col = "light blue",breaks = 100,freq = FALSE,main = "",xlab = expression(italic(M)))
lines(density(prior[,2]))
# Simulated data for a single locus
sample <- sim.inference.model(number.of.sampled.demes = 10,
sample.sizes = 50,M = 2,pi = 0.5)
# Max likelihgood can only be applied to single locus dataset
maximum.likelihood(sample)
library(PopGenInfeR)
# Simulated data for a single locus
sample <- sim.inference.model(number.of.sampled.demes = 10,
sample.sizes = 50,M = 2,pi = 0.5)
# Max likelihgood can only be applied to single locus dataset
maximum.likelihood(sample)
knitr::opts_chunk$set(echo = TRUE)
install.packages("PopGenInfeR",repos="http://R-Forge.R-project.org",dependencies = TRUE)
install.packages("PopGenInfeR", repos = "http://R-Forge.R-project.org", dependencies = TRUE)
install.packages("PopGenInfeR", repos = "http://R-Forge.R-project.org", dependencies = TRUE)
knitr::opts_chunk$set(echo = TRUE)
#install.packages("coda",dependencies = TRUE)
library(coda)
library(PopGenInfeR)
sample <- sim.inference.model(number.of.sampled.demes = 10,sample.sizes = 50,M = 2,pi = 0.5)
sample@counts
sample <- sim.inference.model(number.of.sampled.demes = 10,sample.sizes = 50,M = 2,pi = c(0.5,0.1,0.3))
sample <- sim.inference.model(number.of.sampled.demes = 5,sample.sizes = 50,M = 2,pi = 0.5)
maximum.likelihood(sample)
result <- maximum.likelihood(sample,alpha = 0.05,M = seq(0.01,10,0.01),pi = seq(0.01,0.99,0.01),graphics = TRUE,true.M = 2,true.pi = 0.5)
result
result@max.pi
sample <- sim.inference.model(number.of.sampled.demes = 5,sample.sizes = 50,M = 2,pi = 0.5)
maximum.likelihood(sample)
sample <- sim.inference.model(number.of.sampled.demes = 10,sample.sizes = 50,M = 2,pi = 0.5)
maximum.likelihood(sample)
sample <- sim.inference.model(number.of.sampled.demes = 100,sample.sizes = 50,M = 2,pi = 0.5)
maximum.likelihood(sample)
result <- run.mcmc(sample)
result <- run.mcmc(sample,chain.length = 2000,burnin = 500,range.M = c(0.01,20),delta.M = 0.1,delta.pi = 0.01,alpha = 0.05,graphics = TRUE,true.M = 2,true.pi = 0.5)
autocorr.plot(result)
plot(result)
plot(result)
autocorr.plot(result)
plot(result)
chain1 <- run.mcmc(sample,chain.length = 5000)
chain2 <- run.mcmc(sample,chain.length = 5000)
chain3 <- run.mcmc(sample,chain.length = 5000)
all.chains <- mcmc.list(chain1,chain2,chain3)
gelman.plot(all.chains)
gelman.diag(all.chains)
knitr::opts_chunk$set(echo = TRUE)
library(rehh)
map <- read.table("data/map_subset_23272_snps.inp")
population <- "CEU"
data <- data2haplohh(hap_file = paste("data/haplotypes_subset_23272_snps_",population,".dat",sep = ""),map_file = "data/map_subset_23272_snps.inp")
EHH_result <- calc_ehh(haplohh = data,mrk = 1500) #1500 is a random number here!!!!!!
plot(EHH_result)
remove.packages("ggplot2")
install.packages("ggplot")
install.packages("ggplot2")
remove.packages("ggplot2")
install.packages("ggplot2")
library(ggplot2)
detach("package:ggplot2", unload = TRUE)
remove.packages("ggplot2")
install.packages("ggplot2")
library(tidyverse)
install.packages("tideverse")
install.packages("tideverse")
install.packages("tideverse")
install.packages("tideverse")
run_simulation(threshold_mean = 0.0, threshold_width = 0.0, group_size = 100, time_steps = 100)
source("C:/Users/laksh/Downloads/sociality_practical.R")
View(run_simulation)
gc()
gc()
library("ggplot2")
# function to run simulation
run_simulation <- function(threshold_mean, threshold_width, group_size, time_steps) {
task_efficiency <- 2 / group_size # set the task efficiency so that half of the individuals of the group are needed to deplete the task stimulus, i.e. set task ratios at 50:50
task <- 0 # individuals start with task 0 (foraging)
time_spend_on_tasks <- c(0, 0) # record the time that each individual spends on the tasks
task_transition <- 0 # record number of task transitions
group <- list() # empty vector
for (i in c(1:group_size)) { # loop through the number of individuals
threshold <- rnorm(1, mean = threshold_mean, sd = threshold_width) # sample a threshold value
individual <- list(threshold, task, time_spend_on_tasks, task_transition) # create and individual as a list of properties
group[[i]] <- individual # add the individual to the group vector
}
task_urgency <- 0 # start the simulation with task urgency 0
for (t in c(1:time_steps)) { # loop through time
task_urgency <- task_urgency + 1 # task urgency increases every time step
individuals_doing_task_0 <- 0 # set the counter for individuals foraging to 0
for (i in c(1:group_size)) { # loop through individuals
if (group[[i]][[1]] < task_urgency) { # if their threshold is below the task stimulus
if (group[[i]][[2]] == 1) { # if they previously stayed inside the nest
group[[i]][[4]] <- group[[i]][[4]] + 1 # add a task transition
}
group[[i]][[2]] <- 0 # set task to foraging
group[[i]][[3]][1] <- group[[i]][[3]][1] + 1 # count the foraging event
individuals_doing_task_0 <- individuals_doing_task_0 + 1 # count the foraging individual
} else { # if the threshold is not smaller than the task stimulus
if (group[[i]][[2]] == 0) { # if the individual foraged previously
group[[i]][[4]] <- group[[i]][[4]] + 1 # add a task transition
}
group[[i]][[2]] <- 1 # change task to 1, i.e. staying inside the nest
group[[i]][[3]][2] <- group[[i]][[3]][2] + 1 # record the task
}
}
task_urgency <- task_urgency - individuals_doing_task_0 * task_efficiency # subtract the amount of stimulus reduction
}
ind_thresholds <- vector() # empty vector to record thresholds of individuals
prop_task_0 <- vector() # empty vector to record proportion of time spend foraging for each individual
ci <- vector() # empty vector for division-of-labour-metric calculation
for (i in c(1:group_size)) { # loop through individuals
ind_thresholds <- c(ind_thresholds, group[[i]][[1]]) # get all the threshold
prop_task_0 <- c(prop_task_0, group[[i]][[3]][1] / (group[[i]][[3]][1] + group[[i]][[3]][2])) # get the proportion of time spend foraging
ci <- c(ci, group[[i]][[4]] / time_steps) # calculate transitions per time
}
data <- data.frame(ind_thresholds, prop_task_0, ci) # put data in data frame
print(mean(1 - 2 * data$ci)) # print division-of-labour metric to the console
# plot proportion of time spend foraging as a function of the threshold value of the individual
ggplot(data, aes(x = ind_thresholds, y = prop_task_0)) +
geom_point(size = 1.5, alpha = 0.8, col = "grey")+
scale_y_continuous(name="Proportion of time foraging", limits = c(0.0, 1.0), breaks = seq(0.0, 1.0, 0.2))+
scale_x_continuous(name="Threshold value", limits = c(threshold_mean - 4 * threshold_width, threshold_mean + 4 * threshold_width))+
theme_minimal() +
theme(
axis.text = element_text(size=11,face="plain",color="black"),
axis.title = element_text(size = 13),
axis.line = element_line(color="black", linewidth = 0.6),
panel.border = element_rect(colour = "darkgray", fill=NA, linewidth=0.5)
)
}
run_simulation(threshold_mean = 0.0, threshold_width = 0.0, group_size = 100, time_steps = 100)
run_simulation(threshold_mean = 0.0, threshold_width = 0.1, group_size = 100, time_steps = 100)
run_simulation(threshold_mean = 0.0, threshold_width = 0.2, group_size = 100, time_steps = 100)
run_simulation(threshold_mean = 0.0, threshold_width = 0.3, group_size = 100, time_steps = 100)
run_simulation(threshold_mean = 0.0, threshold_width = 0.5, group_size = 100, time_steps = 100)
run_simulation(threshold_mean = 0.0, threshold_width = 0.6, group_size = 100, time_steps = 100)
run_simulation(threshold_mean = 0.0, threshold_width = 0.6, group_size = 2, time_steps = 100)
run_simulation(threshold_mean = 0.0, threshold_width = 0.6, group_size = 2, time_steps = 100)
ci <- c(ci, group[[i]][[4]] / time_steps) # calculate transitions per time
run_simulation(threshold_mean = 0.0, threshold_width = 0.6, group_size = 2, time_steps = 100)
run_simulation(threshold_mean = 0.0, threshold_width = 0.6, group_size = 2, time_steps = 100)
run_simulation(threshold_mean = 0.0, threshold_width = 0.6, group_size = 2, time_steps = 100)
source("C:/Users/laksh/Downloads/OGH_Eusociality/z_RunData/081223_TesRun_HighMutation/analysis_evolution.R")
# Install and load necessary libraries
# install.packages("tidyverse")
library(tidyverse)
# Read the CSV file
data <- read.csv("output_evolution.csv")
# Read the CSV file
data <- read.csv("output_evolution.csv")
setwd("C:/Users/laksh/Downloads/OGH_Eusociality/z_RunData/081223_TesRun_HighMutation")
# Read the CSV file
data <- read.csv("output_evolution.csv")
# Plot choice_int_avg vs gtime
ggplot(data, aes(x = gtime, y = choice_int_avg)) +
geom_line() +
labs(title = "Choice Intercept Average vs. gtime", x = "gtime", y = "Choice Intercept Average")
gc()
# Plot choice_slope_avg vs gtime
ggplot(data, aes(x = gtime, y = choice_slope_avg)) +
geom_line() +
labs(title = "Choice Slope Average vs. gtime", x = "gtime", y = "Choice Slope Average")
# Plot dispersal_mean vs gtime
ggplot(data, aes(x = gtime, y = dispersal_mean)) +
geom_line() +
labs(title = "Dispersal Mean vs. gtime", x = "gtime", y = "Dispersal Mean")
setwd("C:/Users/laksh/Downloads/OGH_Eusociality/z_RunData/081223_TesRun_HighMutationv2")
# Read the CSV file
data <- read.csv("output_evolution.csv")
# Plot choice_int_avg vs gtime
ggplot(data, aes(x = gtime, y = choice_int_avg)) +
geom_line() +
labs(title = "Choice Intercept Average vs. gtime", x = "gtime", y = "Choice Intercept Average")
# Plot choice_slope_avg vs gtime
ggplot(data, aes(x = gtime, y = choice_slope_avg)) +
geom_line() +
labs(title = "Choice Slope Average vs. gtime", x = "gtime", y = "Choice Slope Average")
# Read the higher mutation v2 CSV file
data <- read.csv("output_LastOfUs.csv")
# Subset data for individuals with t_death != -1
subset_data <- data[data$t_death != -1, ]
# Calculate lifespan
subset_data$lifespan <- subset_data$t_death - subset_data$t_birth
# Subset data for individuals with t_death != -1
subset_data <- data[data$t_death != -1, ]
# Calculate lifespan
subset_data$lifespan <- subset_data$t_death - subset_data$t_birth
# Calculate lifespan
subset_data$lifespan <- subset_data$t_death - subset_data$t_birth
# Plot histogram
hist(subset_data$lifespan, main="Histogram of Lifespans", xlab="Lifespan", col="lightblue", border="black")
# Add a line at the average lifespan
avg_lifespan <- mean(subset_data$lifespan, na.rm = TRUE)
abline(v = avg_lifespan, col="red", lwd=2)
# Print average lifespan on the graph
text(avg_lifespan, 10, labels = paste("Average Lifespan:", round(avg_lifespan, 2)), col="red")
abline(v = avg_lifespan, col="red", lwd=2)
# Print average lifespan on the graph
text(avg_lifespan, 10, labels = paste("Average Lifespan:", round(avg_lifespan, 2)), col="red")
# Print average lifespan to the console
cat("Average Lifespan:", round(avg_lifespan, 2), "\n")
# Calculate and print average time per generation
total_gtime <- max(data$gtime)
generations_passed <- total_gtime / mean(subset_data$lifespan)
cat(round(generations_passed, 2), " generations done in ", total_gtime, "gtime \n")
# So total number of generations in long model are
evolution_numGen = 100000 / avg_lifespan
cat(evolution_numGen ," generations done in long evolutiono of 100000 gtime \n")
